/*
 * ***** BEGIN GPL LICENSE BLOCK *****
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 * Contributor(s): Blender Foundation (2008), Nathan Letwory
 *
 * ***** END GPL LICENSE BLOCK *****
 */

/** \file blender/makesrna/intern/rna_material.c
 *  \ingroup RNA
 */

#include <float.h>
#include <stdlib.h>

#include "DNA_material_types.h"
#include "DNA_texture_types.h"

#include "RNA_define.h"
#include "RNA_enum_types.h"

#include "rna_internal.h"

#include "WM_api.h"
#include "WM_types.h"

const EnumPropertyItem rna_enum_ramp_blend_items[] = {
	{MA_RAMP_BLEND, "MIX", 0, "Mix", ""},
	{MA_RAMP_ADD, "ADD", 0, "Add", ""},
	{MA_RAMP_MULT, "MULTIPLY", 0, "Multiply", ""},
	{MA_RAMP_SUB, "SUBTRACT", 0, "Subtract", ""},
	{MA_RAMP_SCREEN, "SCREEN", 0, "Screen", ""},
	{MA_RAMP_DIV, "DIVIDE", 0, "Divide", ""},
	{MA_RAMP_DIFF, "DIFFERENCE", 0, "Difference", ""},
	{MA_RAMP_DARK, "DARKEN", 0, "Darken", ""},
	{MA_RAMP_LIGHT, "LIGHTEN", 0, "Lighten", ""},
	{MA_RAMP_OVERLAY, "OVERLAY", 0, "Overlay", ""},
	{MA_RAMP_DODGE, "DODGE", 0, "Dodge", ""},
	{MA_RAMP_BURN, "BURN", 0, "Burn", ""},
	{MA_RAMP_HUE, "HUE", 0, "Hue", ""},
	{MA_RAMP_SAT, "SATURATION", 0, "Saturation", ""},
	{MA_RAMP_VAL, "VALUE", 0, "Value", ""},
	{MA_RAMP_COLOR, "COLOR", 0, "Color", ""},
	{MA_RAMP_SOFT, "SOFT_LIGHT", 0, "Soft Light", ""},
	{MA_RAMP_LINEAR, "LINEAR_LIGHT", 0, "Linear Light", ""},
	{0, NULL, 0, NULL, NULL}
};

#ifdef RNA_RUNTIME

#include "MEM_guardedalloc.h"

#include "DNA_node_types.h"
#include "DNA_object_types.h"
#include "DNA_screen_types.h"
#include "DNA_space_types.h"

#include "BKE_colorband.h"
#include "BKE_context.h"
#include "BKE_main.h"
#include "BKE_material.h"
#include "BKE_texture.h"
#include "BKE_node.h"
#include "BKE_paint.h"
#include "BKE_scene.h"
#include "BKE_workspace.h"

#include "DEG_depsgraph.h"
#include "DEG_depsgraph_build.h"

#include "ED_node.h"
#include "ED_image.h"
#include "ED_screen.h"

static void rna_Material_update(Main *UNUSED(bmain), Scene *UNUSED(scene), PointerRNA *ptr)
{
	Material *ma = ptr->id.data;

	DEG_id_tag_update(&ma->id, 0);
	WM_main_add_notifier(NC_MATERIAL | ND_SHADING, ma);
}

static void rna_Material_update_previews(Main *UNUSED(bmain), Scene *UNUSED(scene), PointerRNA *ptr)
{
	Material *ma = ptr->id.data;
	
	if (ma->nodetree)
		BKE_node_preview_clear_tree(ma->nodetree);
		
	WM_main_add_notifier(NC_MATERIAL | ND_SHADING_PREVIEW, ma);
}

static void rna_Material_draw_update(Main *UNUSED(bmain), Scene *UNUSED(scene), PointerRNA *ptr)
{
	Material *ma = ptr->id.data;

	DEG_id_tag_update(&ma->id, 0);
	WM_main_add_notifier(NC_MATERIAL | ND_SHADING_DRAW, ma);
}

static PointerRNA rna_Material_mirror_get(PointerRNA *ptr)
{
	return rna_pointer_inherit_refine(ptr, &RNA_MaterialRaytraceMirror, ptr->id.data);
}

<<<<<<< HEAD
static PointerRNA rna_Material_transp_get(PointerRNA *ptr)
{
	return rna_pointer_inherit_refine(ptr, &RNA_MaterialRaytraceTransparency, ptr->id.data);
}

static PointerRNA rna_Material_halo_get(PointerRNA *ptr)
{
	return rna_pointer_inherit_refine(ptr, &RNA_MaterialHalo, ptr->id.data);
}

static PointerRNA rna_Material_sss_get(PointerRNA *ptr)
{
	return rna_pointer_inherit_refine(ptr, &RNA_MaterialSubsurfaceScattering, ptr->id.data);
}

static PointerRNA rna_Material_strand_get(PointerRNA *ptr)
{
	return rna_pointer_inherit_refine(ptr, &RNA_MaterialStrand, ptr->id.data);
}

static PointerRNA rna_Material_physics_get(PointerRNA *ptr)
{
	return rna_pointer_inherit_refine(ptr, &RNA_MaterialPhysics, ptr->id.data);
}

static void rna_Material_type_set(PointerRNA *ptr, int value)
{
	Material *ma = (Material *)ptr->data;

	if (ma->material_type == MA_TYPE_HALO && value != MA_TYPE_HALO)
		ma->mode &= ~(MA_STAR | MA_HALO_XALPHA | MA_ZINV | MA_ENV);

	ma->material_type = value;
}

static void rna_Material_mtex_begin(CollectionPropertyIterator *iter, PointerRNA *ptr)
{
	Material *ma = (Material *)ptr->data;
	rna_iterator_array_begin(iter, (void *)ma->mtex, sizeof(MTex *), MAX_MTEX, 0, NULL);
}

=======
>>>>>>> b/blender2.8
static void rna_Material_texpaint_begin(CollectionPropertyIterator *iter, PointerRNA *ptr)
{
	Material *ma = (Material *)ptr->data;
	rna_iterator_array_begin(iter, (void *)ma->texpaintslot, sizeof(TexPaintSlot), ma->tot_slots, 0, NULL);
}


static void rna_Material_active_paint_texture_index_update(Main *bmain, Scene *scene, PointerRNA *ptr)
{
	bScreen *sc;
	Material *ma = ptr->id.data;

	if (ma->use_nodes && ma->nodetree) {
		struct bNode *node;
		int index = 0;
		for (node = ma->nodetree->nodes.first; node; node = node->next) {
			if (node->typeinfo->nclass == NODE_CLASS_TEXTURE && node->typeinfo->type == SH_NODE_TEX_IMAGE && node->id) {
				if (index++ == ma->paint_active_slot) {
					break;
				}
			}
		}
		if (node)
			nodeSetActive(ma->nodetree, node);
	}

	if (ma->texpaintslot) {
		Image *image = ma->texpaintslot[ma->paint_active_slot].ima;
		for (sc = bmain->screen.first; sc; sc = sc->id.next) {
			wmWindow *win = ED_screen_window_find(sc, bmain->wm.first);
			if (win == NULL) {
				continue;
			}

			Object *obedit = NULL;
			{
				WorkSpace *workspace = WM_window_get_active_workspace(win);
				ViewLayer *view_layer = BKE_workspace_view_layer_get(workspace, scene);
				obedit = OBEDIT_FROM_VIEW_LAYER(view_layer);
			}

			ScrArea *sa;
			for (sa = sc->areabase.first; sa; sa = sa->next) {
				SpaceLink *sl;
				for (sl = sa->spacedata.first; sl; sl = sl->next) {
					if (sl->spacetype == SPACE_IMAGE) {
						SpaceImage *sima = (SpaceImage *)sl;
						if (!sima->pin) {
							ED_space_image_set(sima, scene, obedit, image);
						}
					}
				}
			}
		}
	}

	DEG_id_tag_update(&ma->id, 0);
	WM_main_add_notifier(NC_MATERIAL | ND_SHADING, ma);
}

static void rna_Material_use_nodes_update(bContext *C, PointerRNA *ptr)
{
	Material *ma = (Material *)ptr->data;
	Main *bmain = CTX_data_main(C);

	if (ma->use_nodes && ma->nodetree == NULL)
		ED_node_shader_default(C, &ma->id);

	DEG_relations_tag_update(bmain);
	rna_Material_draw_update(bmain, CTX_data_scene(C), ptr);
}

MTex *rna_mtex_texture_slots_add(ID *self_id, struct bContext *C, ReportList *reports)
{
	MTex *mtex = BKE_texture_mtex_add_id(self_id, -1);
	if (mtex == NULL) {
		BKE_reportf(reports, RPT_ERROR, "Maximum number of textures added %d", MAX_MTEX);
		return NULL;
	}

	/* for redraw only */
	WM_event_add_notifier(C, NC_TEXTURE, CTX_data_scene(C));

	return mtex;
}

MTex *rna_mtex_texture_slots_create(ID *self_id, struct bContext *C, ReportList *reports, int index)
{
	MTex *mtex;

	if (index < 0 || index >= MAX_MTEX) {
		BKE_reportf(reports, RPT_ERROR, "Index %d is invalid", index);
		return NULL;
	}

	mtex = BKE_texture_mtex_add_id(self_id, index);

	/* for redraw only */
	WM_event_add_notifier(C, NC_TEXTURE, CTX_data_scene(C));

	return mtex;
}

void rna_mtex_texture_slots_clear(ID *self_id, struct bContext *C, ReportList *reports, int index)
{
	MTex **mtex_ar;
	short act;

	give_active_mtex(self_id, &mtex_ar, &act);

	if (mtex_ar == NULL) {
		BKE_report(reports, RPT_ERROR, "Mtex not found for this type");
		return;
	}
	
	if (index < 0 || index >= MAX_MTEX) {
		BKE_reportf(reports, RPT_ERROR, "Index %d is invalid", index);
		return;
	}

	if (mtex_ar[index]) {
		id_us_min((ID *)mtex_ar[index]->tex);
		MEM_freeN(mtex_ar[index]);
		mtex_ar[index] = NULL;
		DEG_id_tag_update(self_id, 0);
	}

	/* for redraw only */
	WM_event_add_notifier(C, NC_TEXTURE, CTX_data_scene(C));
}

#else

<<<<<<< HEAD
static void rna_def_material_mtex(BlenderRNA *brna)
{
	StructRNA *srna;
	PropertyRNA *prop;

	static const EnumPropertyItem prop_mapping_items[] = {
		{MTEX_FLAT, "FLAT", 0, "Flat", "Map X and Y coordinates directly"},
		{MTEX_CUBE, "CUBE", 0, "Cube", "Map using the normal vector"},
		{MTEX_TUBE, "TUBE", 0, "Tube", "Map with Z as central axis"},
		{MTEX_SPHERE, "SPHERE", 0, "Sphere", "Map with Z as central axis"},
		{0, NULL, 0, NULL, NULL}
	};
		
	static const EnumPropertyItem prop_x_mapping_items[] = {
		{0, "NONE", 0, "None", ""},
		{1, "X", 0, "X", ""},
		{2, "Y", 0, "Y", ""},
		{3, "Z", 0, "Z", ""},
		{0, NULL, 0, NULL, NULL}
	};
		
	static const EnumPropertyItem prop_y_mapping_items[] = {
		{0, "NONE", 0, "None", ""},
		{1, "X", 0, "X", ""},
		{2, "Y", 0, "Y", ""},
		{3, "Z", 0, "Z", ""},
		{0, NULL, 0, NULL, NULL}
	};
		
	static const EnumPropertyItem prop_z_mapping_items[] = {
		{0, "NONE", 0, "None", ""},
		{1, "X", 0, "X", ""},
		{2, "Y", 0, "Y", ""},
		{3, "Z", 0, "Z", ""},
		{0, NULL, 0, NULL, NULL}
	};

	static const EnumPropertyItem prop_normal_map_space_items[] = {
		{MTEX_NSPACE_CAMERA, "CAMERA", 0, "Camera", ""},
		{MTEX_NSPACE_WORLD, "WORLD", 0, "World", ""},
		{MTEX_NSPACE_OBJECT, "OBJECT", 0, "Object", ""},
		{MTEX_NSPACE_TANGENT, "TANGENT", 0, "Tangent", ""},
		{0, NULL, 0, NULL, NULL}
	};

	static const EnumPropertyItem prop_bump_method_items[] = {
		{0, "BUMP_ORIGINAL", 0, "Original", ""},
		{MTEX_COMPAT_BUMP, "BUMP_COMPATIBLE", 0, "Compatible", ""},
		{MTEX_3TAP_BUMP, "BUMP_LOW_QUALITY", 0, "Low Quality", "Use 3 tap filtering"},
		{MTEX_5TAP_BUMP, "BUMP_MEDIUM_QUALITY", 0, "Medium Quality", "Use 5 tap filtering"},
		{MTEX_BICUBIC_BUMP, "BUMP_BEST_QUALITY", 0,
		 "Best Quality", "Use bicubic filtering (requires OpenGL 3.0+, it will fall back on "
		 "medium setting for other systems)"},
		{0, NULL, 0, NULL, NULL}
	};

	static const EnumPropertyItem prop_bump_space_items[] = {
		{0, "BUMP_VIEWSPACE", 0, "ViewSpace", ""},
		{MTEX_BUMP_OBJECTSPACE, "BUMP_OBJECTSPACE", 0, "ObjectSpace", ""},
		{MTEX_BUMP_TEXTURESPACE, "BUMP_TEXTURESPACE", 0, "TextureSpace", ""},
		{0, NULL, 0, NULL, NULL}
	};
	
	srna = RNA_def_struct(brna, "MaterialTextureSlot", "TextureSlot");
	RNA_def_struct_sdna(srna, "MTex");
	RNA_def_struct_ui_text(srna, "Material Texture Slot", "Texture slot for textures in a Material data-block");

	prop = RNA_def_property(srna, "texture_coords", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_sdna(prop, NULL, "texco");
	RNA_def_property_enum_items(prop, prop_texture_coordinates_items);
	RNA_def_property_enum_funcs(prop, NULL, NULL, "rna_Material_texture_coordinates_itemf");
	RNA_def_property_ui_text(prop, "Texture Coordinates", "");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "object", PROP_POINTER, PROP_NONE);
	RNA_def_property_pointer_sdna(prop, NULL, "object");
	RNA_def_property_struct_type(prop, "Object");
	RNA_def_property_flag(prop, PROP_EDITABLE);
	RNA_def_property_ui_text(prop, "Object", "Object to use for mapping with Object texture coordinates");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "uv_layer", PROP_STRING, PROP_NONE);
	RNA_def_property_string_sdna(prop, NULL, "uvname");
	RNA_def_property_ui_text(prop, "UV Map", "UV map to use for mapping with UV texture coordinates");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "use_from_dupli", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "texflag", MTEX_DUPLI_MAPTO);
	RNA_def_property_ui_text(prop, "From Dupli",
	                         "Dupli's instanced from verts, faces or particles, inherit texture coordinate "
	                         "from their parent");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "use_map_to_bounds", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "texflag", MTEX_MAPTO_BOUNDS);
	RNA_def_property_ui_text(prop, "Map to Bounds",
	                         "Map coordinates in object bounds");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "use_from_original", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "texflag", MTEX_OB_DUPLI_ORIG);
	RNA_def_property_ui_text(prop, "From Original",
	                         "Dupli's derive their object coordinates from the original object's transformation");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "use_map_color_diffuse", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_COL);
	RNA_def_property_ui_text(prop, "Diffuse Color", "The texture affects basic color of the material");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_normal", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_NORM);
	RNA_def_property_ui_text(prop, "Normal", "The texture affects the rendered normal");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_color_spec", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_COLSPEC);
	RNA_def_property_ui_text(prop, "Specular Color", "The texture affects the specularity color");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_mirror", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_COLMIR);
	RNA_def_property_ui_text(prop, "Mirror", "The texture affects the mirror color");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_diffuse", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_REF);
	RNA_def_property_ui_text(prop, "Diffuse", "The texture affects the value of diffuse reflectivity");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_specular", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_SPEC);
	RNA_def_property_ui_text(prop, "Specular", "The texture affects the value of specular reflectivity");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_ambient", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_AMB);
	RNA_def_property_ui_text(prop, "Ambient", "The texture affects the value of ambient");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_hardness", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_HAR);
	RNA_def_property_ui_text(prop, "Hardness", "The texture affects the hardness value");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_raymir", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_RAYMIRR);
	RNA_def_property_ui_text(prop, "Ray-Mirror", "The texture affects the ray-mirror value");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_alpha", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_ALPHA);
	RNA_def_property_ui_text(prop, "Alpha", "The texture affects the alpha value");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_emit", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_EMIT);
	RNA_def_property_ui_text(prop, "Emit", "The texture affects the emit value");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_translucency", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_TRANSLU);
	RNA_def_property_ui_text(prop, "Translucency", "The texture affects the translucency value");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_displacement", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_DISPLACE);
	RNA_def_property_ui_text(prop, "Displacement", "Let the texture displace the surface");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_warp", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_WARP);
	RNA_def_property_ui_text(prop, "Warp", "Let the texture warp texture coordinates of next channels");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "mapping_x", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_sdna(prop, NULL, "projx");
	RNA_def_property_enum_items(prop, prop_x_mapping_items);
	RNA_def_property_ui_text(prop, "X Mapping", "");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "mapping_y", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_sdna(prop, NULL, "projy");
	RNA_def_property_enum_items(prop, prop_y_mapping_items);
	RNA_def_property_ui_text(prop, "Y Mapping", "");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "mapping_z", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_sdna(prop, NULL, "projz");
	RNA_def_property_enum_items(prop, prop_z_mapping_items);
	RNA_def_property_ui_text(prop, "Z Mapping", "");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "mapping", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_items(prop, prop_mapping_items);
	RNA_def_property_ui_text(prop, "Mapping", "");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "normal_map_space", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_sdna(prop, NULL, "normapspace");
	RNA_def_property_enum_items(prop, prop_normal_map_space_items);
	RNA_def_property_ui_text(prop, "Normal Map Space", "Set space of normal map image");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "normal_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "norfac");
	RNA_def_property_ui_range(prop, -5, 5, 10, 3);
	RNA_def_property_ui_text(prop, "Normal Factor", "Amount texture affects normal values");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "displacement_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "dispfac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Displacement Factor", "Amount texture displaces the surface");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "warp_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "warpfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Warp Factor", "Amount texture affects texture coordinates of next channels");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "specular_color_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "colspecfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Specular Color Factor", "Amount texture affects specular color");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "diffuse_color_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "colfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Diffuse Color Factor", "Amount texture affects diffuse color");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "mirror_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "mirrfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Mirror Factor", "Amount texture affects mirror color");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "alpha_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "alphafac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Alpha Factor", "Amount texture affects alpha");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "diffuse_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "difffac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Diffuse Factor", "Amount texture affects diffuse reflectivity");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "specular_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "specfac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Specular Factor", "Amount texture affects specular reflectivity");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "emit_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "emitfac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Emit Factor", "Amount texture affects emission");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "hardness_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "hardfac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Hardness Factor", "Amount texture affects hardness");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "raymir_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "raymirrfac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Ray Mirror Factor", "Amount texture affects ray mirror");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "translucency_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "translfac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Translucency Factor", "Amount texture affects translucency");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "ambient_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "ambfac");
	RNA_def_property_ui_range(prop, -1, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Ambient Factor", "Amount texture affects ambient");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	/* volume material */
	prop = RNA_def_property(srna, "use_map_color_emission", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_EMISSION_COL);
	RNA_def_property_ui_text(prop, "Emission Color", "The texture affects the color of emission");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_color_reflection", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_REFLECTION_COL);
	RNA_def_property_ui_text(prop, "Reflection Color", "The texture affects the color of scattered light");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_color_transmission", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_TRANSMISSION_COL);
	RNA_def_property_ui_text(prop, "Transmission Color",
	                         "The texture affects the result color after other light has been scattered/absorbed");
	RNA_def_property_update(prop, NC_TEXTURE, NULL);
	
	prop = RNA_def_property(srna, "use_map_density", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_DENSITY);
	RNA_def_property_ui_text(prop, "Density", "The texture affects the volume's density");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_emission", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_EMISSION);
	RNA_def_property_ui_text(prop, "Emission", "The texture affects the volume's emission");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_scatter", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_SCATTERING);
	RNA_def_property_ui_text(prop, "Scattering", "The texture affects the volume's scattering");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "use_map_reflect", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "mapto", MAP_REFLECTION);
	RNA_def_property_ui_text(prop, "Reflection", "The texture affects the reflected light's brightness");
	RNA_def_property_update(prop, NC_TEXTURE, NULL);
	
	prop = RNA_def_property(srna, "emission_color_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "colemitfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Emission Color Factor", "Amount texture affects emission color");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "reflection_color_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "colreflfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Reflection Color Factor", "Amount texture affects color of out-scattered light");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "transmission_color_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "coltransfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Transmission Color Factor",
	                         "Amount texture affects result color after light has been scattered/absorbed");
	RNA_def_property_update(prop, NC_TEXTURE, NULL);
	
	prop = RNA_def_property(srna, "density_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "densfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Density Factor", "Amount texture affects density");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "emission_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "emitfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Emission Factor", "Amount texture affects emission");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "scattering_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "scatterfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Scattering Factor", "Amount texture affects scattering");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "reflection_factor", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "reflfac");
	RNA_def_property_ui_range(prop, 0, 1, 10, 3);
	RNA_def_property_ui_text(prop, "Reflection Factor", "Amount texture affects brightness of out-scattered light");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	/* end volume material */
	
	prop = RNA_def_property(srna, "use", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_funcs(prop, "rna_MaterialTextureSlot_use_get", "rna_MaterialTextureSlot_use_set");
	RNA_def_property_ui_text(prop, "Enabled", "Enable this material texture slot");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "bump_method", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_bitflag_sdna(prop, NULL, "texflag");
	RNA_def_property_enum_items(prop, prop_bump_method_items);
	RNA_def_property_ui_text(prop, "Bump Method", "Method to use for bump mapping");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "bump_objectspace", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_bitflag_sdna(prop, NULL, "texflag");
	RNA_def_property_enum_items(prop, prop_bump_space_items);
	RNA_def_property_ui_text(prop, "Bump Space", "Space to apply bump mapping in");
	RNA_def_property_update(prop, 0, "rna_Material_update");
}

static void rna_def_material_gamesettings(BlenderRNA *brna)
{
	StructRNA *srna;
	PropertyRNA *prop;

	static const EnumPropertyItem prop_alpha_blend_items[] = {
		{GEMAT_SOLID, "OPAQUE", 0, "Opaque", "Render color of textured face as color"},
		{GEMAT_ADD, "ADD", 0, "Add", "Render face transparent and add color of face"},
		{GEMAT_CLIP, "CLIP", 0, "Alpha Clip", "Use the image alpha values clipped with no blending (binary alpha)"},
		{GEMAT_ALPHA, "ALPHA", 0, "Alpha Blend",
		 "Render polygon transparent, depending on alpha channel of the texture"},
		{GEMAT_ALPHA_SORT, "ALPHA_SORT", 0, "Alpha Sort",
		 "Sort faces for correct alpha drawing (slow, use Alpha Clip instead when possible)"},
		{GEMAT_ALPHA_TO_COVERAGE, "ALPHA_ANTIALIASING", 0, "Alpha Anti-Aliasing",
		 "Use textures alpha as anti-aliasing mask, requires multi-sample OpenGL display"},
		{0, NULL, 0, NULL, NULL}
	};

	static const EnumPropertyItem prop_face_orientation_items[] = {
		{GEMAT_NORMAL, "NORMAL", 0, "Normal", "No transformation"},
		{GEMAT_HALO, "HALO", 0, "Halo", "Screen aligned billboard"},
		{GEMAT_BILLBOARD, "BILLBOARD", 0, "Billboard", "Billboard with Z-axis constraint"},
		{GEMAT_SHADOW, "SHADOW", 0, "Shadow", "Faces are used for shadow"},
		{0, NULL, 0, NULL, NULL}
	};
	
	srna = RNA_def_struct(brna, "MaterialGameSettings", NULL);
	RNA_def_struct_sdna(srna, "GameSettings");
	RNA_def_struct_nested(brna, srna, "Material");
	RNA_def_struct_ui_text(srna, "Material Game Settings", "Game Engine settings for a Material data-block");
	
	prop = RNA_def_property(srna, "use_backface_culling", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "flag", GEMAT_BACKCULL); /* use bitflags */
	RNA_def_property_ui_text(prop, "Backface Culling", "Hide Back of the face in Game Engine ");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "text", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "flag", GEMAT_TEXT); /* use bitflags */
	RNA_def_property_ui_text(prop, "Text", "Use material as text in Game Engine ");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "invisible", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "flag", GEMAT_INVISIBLE); /* use bitflags */
	RNA_def_property_ui_text(prop, "Invisible", "Make face invisible");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "alpha_blend", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_sdna(prop, NULL, "alpha_blend");
	RNA_def_property_enum_items(prop, prop_alpha_blend_items);
	RNA_def_property_ui_text(prop, "Blend Mode", "Blend Mode for Transparent Faces");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "face_orientation", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_items(prop, prop_face_orientation_items);
	RNA_def_property_ui_text(prop, "Face Orientations", "Especial face orientation options");

	prop = RNA_def_property(srna, "physics", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_negative_sdna(prop, NULL, "flag", GEMAT_NOPHYSICS); /* use bitflags */
	RNA_def_property_ui_text(prop, "Physics", "Use physics properties of materials ");
}

=======
>>>>>>> b/blender2.8
static void rna_def_material_colors(StructRNA *srna)
{
	PropertyRNA *prop;

	prop = RNA_def_property(srna, "diffuse_color", PROP_FLOAT, PROP_COLOR);
	RNA_def_property_float_sdna(prop, NULL, "r");
	RNA_def_property_array(prop, 3);
	RNA_def_property_ui_text(prop, "Diffuse Color", "Diffuse color of the material");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
	
	prop = RNA_def_property(srna, "specular_color", PROP_FLOAT, PROP_COLOR);
	RNA_def_property_float_sdna(prop, NULL, "specr");
	RNA_def_property_array(prop, 3);
	RNA_def_property_ui_text(prop, "Specular Color", "Specular color of the material");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");
	
	prop = RNA_def_property(srna, "specular_intensity", PROP_FLOAT, PROP_FACTOR);
	RNA_def_property_float_sdna(prop, NULL, "spec");
	RNA_def_property_range(prop, 0, 1);
	RNA_def_property_ui_text(prop, "Specular Intensity", "How intense (bright) the specular reflection is");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "alpha", PROP_FLOAT, PROP_FACTOR);
	RNA_def_property_range(prop, 0.0f, 1.0f);
	RNA_def_property_ui_text(prop, "Alpha", "Alpha transparency of the material");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	/* Freestyle line color */
	prop = RNA_def_property(srna, "line_color", PROP_FLOAT, PROP_COLOR);
	RNA_def_property_float_sdna(prop, NULL, "line_col");
	RNA_def_property_array(prop, 4);
	RNA_def_property_ui_text(prop, "Line Color", "Line color used for Freestyle line rendering");
	RNA_def_property_update(prop, 0, "rna_Material_update");

	prop = RNA_def_property(srna, "line_priority", PROP_INT, PROP_NONE);
	RNA_def_property_int_sdna(prop, NULL, "line_priority");
	RNA_def_property_range(prop, 0, 32767);
	RNA_def_property_ui_text(prop, "Line Priority",
	                         "The line color of a higher priority is used at material boundaries");
	RNA_def_property_update(prop, 0, "rna_Material_update");
}

static void rna_def_material_raymirror(BlenderRNA *brna)
{
	StructRNA *srna;
	PropertyRNA *prop;

	srna = RNA_def_struct(brna, "MaterialRaytraceMirror", NULL);
	RNA_def_struct_sdna(srna, "Material");
	RNA_def_struct_nested(brna, srna, "Material");
	RNA_def_struct_ui_text(srna, "Material Raytrace Mirror", "Raytraced reflection settings for a Material data-block");

	prop = RNA_def_property(srna, "reflect_factor", PROP_FLOAT, PROP_FACTOR);
	RNA_def_property_float_sdna(prop, NULL, "ray_mirror");
	RNA_def_property_range(prop, 0.0f, 1.0f);
	RNA_def_property_ui_text(prop, "Reflectivity", "Amount of mirror reflection for raytrace");
	RNA_def_property_update(prop, 0, "rna_Material_update");
	
	prop = RNA_def_property(srna, "gloss_factor", PROP_FLOAT, PROP_FACTOR);
	RNA_def_property_float_sdna(prop, NULL, "gloss_mir");
	RNA_def_property_range(prop, 0.0f, 1.0f);
	RNA_def_property_ui_text(prop, "Gloss Amount",
	                         "The shininess of the reflection (values < 1.0 give diffuse, blurry reflections)");
	RNA_def_property_update(prop, 0, "rna_Material_update");
}

static void rna_def_material_physics(BlenderRNA *brna)
{
	StructRNA *srna;
	PropertyRNA *prop;
	
	srna = RNA_def_struct(brna, "MaterialPhysics", NULL);
	RNA_def_struct_sdna(srna, "Material");
	RNA_def_struct_nested(brna, srna, "Material");
	RNA_def_struct_ui_text(srna, "Material Physics", "Physics settings for a Material data-block");
	
	prop = RNA_def_property(srna, "friction", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "friction");
	RNA_def_property_range(prop, 0, 100);
	RNA_def_property_ui_text(prop, "Friction", "Coulomb friction coefficient, when inside the physics distance area");

	prop = RNA_def_property(srna, "elasticity", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "reflect");
	RNA_def_property_range(prop, 0, 1);
	RNA_def_property_ui_text(prop, "Elasticity", "Elasticity of collisions");

	/* FH/Force Field Settings */
	prop = RNA_def_property(srna, "use_fh_normal", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "dynamode", MA_FH_NOR);
	RNA_def_property_ui_text(prop, "Align to Normal",
	                         "Align dynamic game objects along the surface normal, "
	                         "when inside the physics distance area");

	prop = RNA_def_property(srna, "fh_force", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "fh");
	RNA_def_property_range(prop, 0, 1);
	RNA_def_property_ui_range(prop, 0.0, 1.0, 10, 2);
	RNA_def_property_ui_text(prop, "Force", "Upward spring force, when inside the physics distance area");
	
	prop = RNA_def_property(srna, "fh_distance", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "fhdist");
	RNA_def_property_range(prop, 0, 20);
	RNA_def_property_ui_text(prop, "Distance", "Distance of the physics area");
	
	prop = RNA_def_property(srna, "fh_damping", PROP_FLOAT, PROP_NONE);
	RNA_def_property_float_sdna(prop, NULL, "xyfrict");
	RNA_def_property_range(prop, 0, 1);
	RNA_def_property_ui_text(prop, "Damping", "Damping of the spring force, when inside the physics distance area");
}

void RNA_def_material(BlenderRNA *brna)
{
	StructRNA *srna;
	PropertyRNA *prop;

	/* Render Preview Types */
	static const EnumPropertyItem preview_type_items[] = {
		{MA_FLAT, "FLAT", ICON_MATPLANE, "Flat", "Flat XY plane"},
		{MA_SPHERE, "SPHERE", ICON_MATSPHERE, "Sphere", "Sphere"},
		{MA_CUBE, "CUBE", ICON_MATCUBE, "Cube", "Cube"},
		{MA_MONKEY, "MONKEY", ICON_MONKEY, "Monkey", "Monkey"},
		{MA_HAIR, "HAIR", ICON_HAIR, "Hair", "Hair strands"},
		{MA_SPHERE_A, "SPHERE_A", ICON_MAT_SPHERE_SKY, "World Sphere", "Large sphere with sky"},
		{0, NULL, 0, NULL, NULL}
	};

	static EnumPropertyItem prop_eevee_blend_items[] = {
		{MA_BM_SOLID, "OPAQUE", 0, "Opaque", "Render surface without transparency"},
		{MA_BM_ADD, "ADD", 0, "Additive", "Render surface and blend the result with additive blending"},
		{MA_BM_MULTIPLY, "MULTIPLY", 0, "Multiply", "Render surface and blend the result with multiplicative blending"},
		{MA_BM_CLIP, "CLIP", 0, "Alpha Clip", "Use the alpha threshold to clip the visibility (binary visibility)"},
		{MA_BM_HASHED, "HASHED", 0, "Alpha Hashed", "Use noise to dither the binary visibility (works well with multi-samples)"},
		{MA_BM_BLEND, "BLEND", 0, "Alpha Blend", "Render polygon transparent, depending on alpha channel of the texture"},
		{0, NULL, 0, NULL, NULL}
	};

	static EnumPropertyItem prop_eevee_blend_shadow_items[] = {
		{MA_BS_NONE, "NONE", 0, "None", "Material will cast no shadow"},
		{MA_BS_SOLID, "OPAQUE", 0, "Opaque", "Material will cast shadows without transparency"},
		{MA_BS_CLIP, "CLIP", 0, "Clip", "Use the alpha threshold to clip the visibility (binary visibility)"},
		{MA_BS_HASHED, "HASHED", 0, "Hashed", "Use noise to dither the binary visibility and use filtering to reduce the noise"},
		{0, NULL, 0, NULL, NULL}
	};

	srna = RNA_def_struct(brna, "Material", "ID");
	RNA_def_struct_ui_text(srna, "Material",
	                       "Material data-block to define the appearance of geometric objects for rendering");
	RNA_def_struct_ui_icon(srna, ICON_MATERIAL_DATA);
	
	/* Blending (only Eevee for now) */
	prop = RNA_def_property(srna, "blend_method", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_items(prop, prop_eevee_blend_items);
	RNA_def_property_ui_text(prop, "Blend Mode", "Blend Mode for Transparent Faces");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "transparent_shadow_method", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_sdna(prop, NULL, "blend_shadow");
	RNA_def_property_enum_items(prop, prop_eevee_blend_shadow_items);
	RNA_def_property_ui_text(prop, "Transparent Shadow", "Shadow method for transparent material");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "alpha_threshold", PROP_FLOAT, PROP_FACTOR);
	RNA_def_property_range(prop, 0, 1);
	RNA_def_property_ui_text(prop, "Clip Threshold", "A pixel is rendered only if its alpha value is above this threshold");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "transparent_hide_backside", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "blend_flag", MA_BL_HIDE_BACKSIDE);
	RNA_def_property_ui_text(prop, "Hide Backside", "Limit transparency to a single layer "
	                                                 "(avoids transparency sorting problems)");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "use_screen_refraction", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "blend_flag", MA_BL_SS_REFRACTION);
	RNA_def_property_ui_text(prop, "Screen Space Refraction", "Use raytraced screen space refractions");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "use_screen_subsurface", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "blend_flag", MA_BL_SS_SUBSURFACE);
	RNA_def_property_ui_text(prop, "Screen Space Subsurface Scattering", "Use post process subsurface scattering");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "use_sss_translucency", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "blend_flag", MA_BL_TRANSLUCENCY);
	RNA_def_property_ui_text(prop, "Subsurface Translucency", "Add translucency effect to subsurface");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	prop = RNA_def_property(srna, "refraction_depth", PROP_FLOAT, PROP_DISTANCE);
	RNA_def_property_float_sdna(prop, NULL, "refract_depth");
	RNA_def_property_range(prop, 0.0f, FLT_MAX);
	RNA_def_property_ui_text(prop, "Refraction Depth", "Approximate the thickness of the object to compute two refraction "
	                                                   "event (0 is disabled)");
	RNA_def_property_update(prop, 0, "rna_Material_draw_update");

	/* For Preview Render */
	prop = RNA_def_property(srna, "preview_render_type", PROP_ENUM, PROP_NONE);
	RNA_def_property_enum_sdna(prop, NULL, "pr_type");
	RNA_def_property_enum_items(prop, preview_type_items);
	RNA_def_property_ui_text(prop, "Preview render type", "Type of preview render");
	RNA_def_property_update(prop, 0, "rna_Material_update_previews");
	
	prop = RNA_def_property(srna, "pass_index", PROP_INT, PROP_UNSIGNED);
	RNA_def_property_int_sdna(prop, NULL, "index");
	RNA_def_property_ui_text(prop, "Pass Index", "Index number for the \"Material Index\" render pass");
	RNA_def_property_update(prop, NC_OBJECT, "rna_Material_update");

	/* nested structs */
	prop = RNA_def_property(srna, "raytrace_mirror", PROP_POINTER, PROP_NONE);
	RNA_def_property_flag(prop, PROP_NEVER_NULL);
	RNA_def_property_struct_type(prop, "MaterialRaytraceMirror");
	RNA_def_property_pointer_funcs(prop, "rna_Material_mirror_get", NULL, NULL, NULL);
	RNA_def_property_ui_text(prop, "Raytrace Mirror", "Raytraced reflection settings for the material");

<<<<<<< HEAD
	prop = RNA_def_property(srna, "raytrace_transparency", PROP_POINTER, PROP_NONE);
	RNA_def_property_flag(prop, PROP_NEVER_NULL);
	RNA_def_property_struct_type(prop, "MaterialRaytraceTransparency");
	RNA_def_property_pointer_funcs(prop, "rna_Material_transp_get", NULL, NULL, NULL);
	RNA_def_property_ui_text(prop, "Raytrace Transparency", "Raytraced transparency settings for the material");

	prop = RNA_def_property(srna, "volume", PROP_POINTER, PROP_NONE);
	RNA_def_property_flag(prop, PROP_NEVER_NULL);
	RNA_def_property_pointer_sdna(prop, NULL, "vol");
	RNA_def_property_struct_type(prop, "MaterialVolume");
	RNA_def_property_ui_text(prop, "Volume", "Volume settings for the material");

	prop = RNA_def_property(srna, "halo", PROP_POINTER, PROP_NONE);
	RNA_def_property_flag(prop, PROP_NEVER_NULL);
	RNA_def_property_struct_type(prop, "MaterialHalo");
	RNA_def_property_pointer_funcs(prop, "rna_Material_halo_get", NULL, NULL, NULL);
	RNA_def_property_ui_text(prop, "Halo", "Halo settings for the material");

	prop = RNA_def_property(srna, "subsurface_scattering", PROP_POINTER, PROP_NONE);
	RNA_def_property_flag(prop, PROP_NEVER_NULL);
	RNA_def_property_struct_type(prop, "MaterialSubsurfaceScattering");
	RNA_def_property_pointer_funcs(prop, "rna_Material_sss_get", NULL, NULL, NULL);
	RNA_def_property_ui_text(prop, "Subsurface Scattering", "Subsurface scattering settings for the material");

	prop = RNA_def_property(srna, "strand", PROP_POINTER, PROP_NONE);
	RNA_def_property_flag(prop, PROP_NEVER_NULL);
	RNA_def_property_struct_type(prop, "MaterialStrand");
	RNA_def_property_pointer_funcs(prop, "rna_Material_strand_get", NULL, NULL, NULL);
	RNA_def_property_ui_text(prop, "Strand", "Strand settings for the material");
	
	prop = RNA_def_property(srna, "physics", PROP_POINTER, PROP_NONE);
	RNA_def_property_flag(prop, PROP_NEVER_NULL);
	RNA_def_property_struct_type(prop, "MaterialPhysics");
	RNA_def_property_pointer_funcs(prop, "rna_Material_physics_get", NULL, NULL, NULL);
	RNA_def_property_ui_text(prop, "Physics", "Game physics settings");

	/* game settings */
	prop = RNA_def_property(srna, "game_settings", PROP_POINTER, PROP_NONE);
	RNA_def_property_flag(prop, PROP_NEVER_NULL);
	RNA_def_property_pointer_sdna(prop, NULL, "game");
	RNA_def_property_struct_type(prop, "MaterialGameSettings");
	RNA_def_property_ui_text(prop, "Game Settings", "Game material settings");

=======
>>>>>>> b/blender2.8
	/* nodetree */
	prop = RNA_def_property(srna, "node_tree", PROP_POINTER, PROP_NONE);
	RNA_def_property_pointer_sdna(prop, NULL, "nodetree");
	RNA_def_property_ui_text(prop, "Node Tree", "Node tree for node based materials");

	prop = RNA_def_property(srna, "use_nodes", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_boolean_sdna(prop, NULL, "use_nodes", 1);
	RNA_def_property_clear_flag(prop, PROP_ANIMATABLE);
	RNA_def_property_flag(prop, PROP_CONTEXT_UPDATE);
	RNA_def_property_ui_text(prop, "Use Nodes", "Use shader nodes to render the material");
	RNA_def_property_update(prop, 0, "rna_Material_use_nodes_update");

	/* common */
	rna_def_animdata_common(srna);
	rna_def_texpaint_slots(brna, srna);

	rna_def_material_colors(srna);
	rna_def_material_raymirror(brna);
<<<<<<< HEAD
	rna_def_material_raytra(brna);
	rna_def_material_volume(brna);
	rna_def_material_halo(brna);
	rna_def_material_sss(brna);
	rna_def_material_mtex(brna);
	rna_def_material_strand(brna);
	rna_def_material_physics(brna);
	rna_def_material_gamesettings(brna);
=======
>>>>>>> b/blender2.8

	RNA_api_material(srna);
}


static void rna_def_texture_slots(BlenderRNA *brna, PropertyRNA *cprop, const char *structname,
                                  const char *structname_slots)
{
	StructRNA *srna;

	FunctionRNA *func;
	PropertyRNA *parm;

	RNA_def_property_srna(cprop, structname_slots);
	srna = RNA_def_struct(brna, structname_slots, NULL);
	RNA_def_struct_sdna(srna, "ID");
	RNA_def_struct_ui_text(srna, "Texture Slots", "Collection of texture slots");

	/* functions */
	func = RNA_def_function(srna, "add", "rna_mtex_texture_slots_add");
	RNA_def_function_flag(func, FUNC_USE_SELF_ID | FUNC_NO_SELF | FUNC_USE_CONTEXT | FUNC_USE_REPORTS);
	parm = RNA_def_pointer(func, "mtex", structname, "", "The newly initialized mtex");
	RNA_def_function_return(func, parm);
	
	func = RNA_def_function(srna, "create", "rna_mtex_texture_slots_create");
	RNA_def_function_flag(func, FUNC_USE_SELF_ID | FUNC_NO_SELF | FUNC_USE_CONTEXT | FUNC_USE_REPORTS);
	parm = RNA_def_int(func, "index", 0, 0, INT_MAX, "Index", "Slot index to initialize", 0, INT_MAX);
	RNA_def_parameter_flags(parm, 0, PARM_REQUIRED);
	parm = RNA_def_pointer(func, "mtex", structname, "", "The newly initialized mtex");
	RNA_def_function_return(func, parm);
	
	func = RNA_def_function(srna, "clear", "rna_mtex_texture_slots_clear");
	RNA_def_function_flag(func, FUNC_USE_SELF_ID | FUNC_NO_SELF | FUNC_USE_CONTEXT | FUNC_USE_REPORTS);
	parm = RNA_def_int(func, "index", 0, 0, INT_MAX, "Index", "Slot index to clear", 0, INT_MAX);
	RNA_def_parameter_flags(parm, 0, PARM_REQUIRED);
}

void rna_def_mtex_common(BlenderRNA *brna, StructRNA *srna, const char *begin,
                         const char *activeget, const char *activeset, const char *activeeditable,
                         const char *structname, const char *structname_slots, const char *update, const char *update_index)
{
	PropertyRNA *prop;

	/* mtex */
	prop = RNA_def_property(srna, "texture_slots", PROP_COLLECTION, PROP_NONE);
	RNA_def_property_struct_type(prop, structname);
	RNA_def_property_collection_funcs(prop, begin, "rna_iterator_array_next", "rna_iterator_array_end",
	                                  "rna_iterator_array_dereference_get", NULL, NULL, NULL, NULL);
	RNA_def_property_ui_text(prop, "Textures", "Texture slots defining the mapping and influence of textures");
	rna_def_texture_slots(brna, prop, structname, structname_slots);

	prop = RNA_def_property(srna, "active_texture", PROP_POINTER, PROP_NONE);
	RNA_def_property_struct_type(prop, "Texture");
	RNA_def_property_flag(prop, PROP_EDITABLE);
	if (activeeditable)
		RNA_def_property_editable_func(prop, activeeditable);
	RNA_def_property_pointer_funcs(prop, activeget, activeset, NULL, NULL);
	RNA_def_property_ui_text(prop, "Active Texture", "Active texture slot being displayed");
	RNA_def_property_update(prop, NC_MATERIAL | ND_SHADING_LINKS, update);

	prop = RNA_def_property(srna, "active_texture_index", PROP_INT, PROP_UNSIGNED);
	RNA_def_property_int_sdna(prop, NULL, "texact");
	RNA_def_property_range(prop, 0, MAX_MTEX - 1);
	RNA_def_property_ui_text(prop, "Active Texture Index", "Index of active texture slot");
	RNA_def_property_update(prop, NC_MATERIAL | ND_SHADING_LINKS, update_index);
}

static void rna_def_tex_slot(BlenderRNA *brna)
{
	StructRNA *srna;
	PropertyRNA *prop;

	srna = RNA_def_struct(brna, "TexPaintSlot", NULL);
	RNA_def_struct_ui_text(srna, "Texture Paint Slot",
	                       "Slot that contains information about texture painting");

	prop = RNA_def_property(srna, "uv_layer", PROP_STRING, PROP_NONE);
	RNA_def_property_string_maxlength(prop, 64); /* else it uses the pointer size! */
	RNA_def_property_string_sdna(prop, NULL, "uvname");
	RNA_def_property_ui_text(prop, "UV Map", "Name of UV map");
	RNA_def_property_update(prop, NC_GEOM | ND_DATA, "rna_Material_update");
	
	prop = RNA_def_property(srna, "valid", PROP_BOOLEAN, PROP_NONE);
	RNA_def_property_clear_flag(prop, PROP_EDITABLE);
	RNA_def_property_ui_text(prop, "Valid", "Slot has a valid image and UV map");
}


void rna_def_texpaint_slots(BlenderRNA *brna, StructRNA *srna)
{
	PropertyRNA *prop;

	rna_def_tex_slot(brna);

	/* mtex */
	prop = RNA_def_property(srna, "texture_paint_images", PROP_COLLECTION, PROP_NONE);
	RNA_def_property_collection_sdna(prop, NULL, "texpaintslot", NULL);
	RNA_def_property_collection_funcs(prop, "rna_Material_texpaint_begin", "rna_iterator_array_next", "rna_iterator_array_end",
	                                  "rna_iterator_array_dereference_get", NULL, NULL, NULL, NULL);
	RNA_def_property_struct_type(prop, "Image");
	RNA_def_property_ui_text(prop, "Texture Slot Images", "Texture images used for texture painting");

	prop = RNA_def_property(srna, "texture_paint_slots", PROP_COLLECTION, PROP_NONE);
	RNA_def_property_collection_funcs(prop, "rna_Material_texpaint_begin", "rna_iterator_array_next", "rna_iterator_array_end",
	                                  "rna_iterator_array_get", NULL, NULL, NULL, NULL);
	RNA_def_property_struct_type(prop, "TexPaintSlot");
	RNA_def_property_ui_text(prop, "Texture Slots", "Texture slots defining the mapping and influence of textures");

	prop = RNA_def_property(srna, "paint_active_slot", PROP_INT, PROP_UNSIGNED);
	RNA_def_property_range(prop, 0, SHRT_MAX);
	RNA_def_property_ui_text(prop, "Active Paint Texture Index", "Index of active texture paint slot");
	RNA_def_property_update(prop, NC_MATERIAL | ND_SHADING_LINKS, "rna_Material_active_paint_texture_index_update");

	prop = RNA_def_property(srna, "paint_clone_slot", PROP_INT, PROP_UNSIGNED);
	RNA_def_property_range(prop, 0, SHRT_MAX);
	RNA_def_property_ui_text(prop, "Clone Paint Texture Index", "Index of clone texture paint slot");
	RNA_def_property_update(prop, NC_MATERIAL | ND_SHADING_LINKS, NULL);
}

#endif
